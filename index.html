<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    canvas {
      border: 1px solid #000;
      cursor: pointer;
      max-width: 100%; /* Ensure the canvas doesn't exceed the width of the viewport */
      height: auto; /* Maintain the aspect ratio of the canvas */
      transition: transform 0.3s ease-in-out; /* Add a smooth transition for the animation */
    }
    .border-label {
      position: absolute;
      font-size: 14px;
      pointer-events: none;
    }
  </style>
  <title>Land Capture Game</title>
</head>
<body>
  <div id="versionInfo" class="border-label">Version: 1.1</div>
  <label for="scaleSlider">Adjust Grid Scale:</label>
  <input type="range" id="scaleSlider" min="25" max="200" step="25" value="100" />
  <br>
  <label for="colorSelector">Select Team Color:</label>
  <select id="colorSelector">
    <option value="red">Red</option>
    <option value="blue">Blue</option>
    <option value="green">Green</option>
    <option value="yellow">Yellow</option>
    <option value="transparent">Transparent</option>
  </select>
  <br>
  <input type="file" id="imageInput" accept="image/jpeg, image/png" />
  <canvas id="gridCanvas"></canvas>
  <button id="undoButton">Undo</button>
  <button id="lockUnlockButton">Lock Map</button>
  <div id="timestamps" class="timestamp"></div>
  <div id="hoverInfo" class="border-label"></div>
  <script>
    document.addEventListener("DOMContentLoaded", function() {
      const canvas = document.getElementById("gridCanvas");
      const context = canvas.getContext("2d");
      const imageInput = document.getElementById("imageInput");
      const scaleSlider = document.getElementById("scaleSlider");
      const colorSelector = document.getElementById("colorSelector");
      const undoButton = document.getElementById("undoButton");
      const lockUnlockButton = document.getElementById("lockUnlockButton");
      const timestampsContainer = document.getElementById("timestamps");
      const hoverInfo = document.getElementById("hoverInfo");

      let image = new Image();
      let isImageLoaded = false;
      let gridSize = parseInt(scaleSlider.value);
      let selectedColor = colorSelector.value;
      let isMapLocked = false;
      let offsetX = 0;
      let offsetY = 0;

      const grid = [];
      const gridHistory = [];

      imageInput.addEventListener("change", function(event) {
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = function(e) {
            image.src = e.target.result;
          };
          reader.readAsDataURL(file);
        }
      });

      scaleSlider.addEventListener("input", function() {
        gridSize = parseInt(scaleSlider.value);
        drawOverlay();
      });

      colorSelector.addEventListener("change", function() {
        selectedColor = colorSelector.value;
      });

      image.onload = function() {
        isImageLoaded = true;
        canvas.width = image.width;
        canvas.height = image.height;
        drawOverlay();
      };

      function drawOverlay() {
        if (!isImageLoaded) return;

        context.clearRect(0, 0, canvas.width, canvas.height);
        context.drawImage(image, offsetX, offsetY, canvas.width, canvas.height);

        context.globalAlpha = 0.5;

        const rows = Math.ceil(canvas.height / gridSize);
        const cols = Math.ceil(canvas.width / gridSize);

        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < cols; j++) {
            const color = grid[i] && grid[i][j] ? grid[i][j].color : "transparent";
            context.fillStyle = color;
            context.fillRect(j * gridSize + offsetX, i * gridSize + offsetY, gridSize, gridSize);
            context.strokeRect(j * gridSize + offsetX, i * gridSize + offsetY, gridSize, gridSize);
          }
        }
        context.globalAlpha = 1;

        drawBorders();
      }

      function drawBorders() {
        context.lineWidth = 2;
        context.strokeStyle = "black";
        context.font = "12px Arial";

        const rows = Math.ceil(canvas.height / gridSize);
        const cols = Math.ceil(canvas.width / gridSize);

        for (let i = 0; i <= rows; i++) {
          const y = i * gridSize + offsetY;
          context.beginPath();
          context.moveTo(0, y);
          context.lineTo(canvas.width, y);
          context.stroke();

          if (i < rows) {
            const label = prompt(`Enter Northing for border row ${i + 1}:`, `N ${i}`);
            context.fillText(label, 5, y + 15);
          }
        }

        for (let j = 0; j <= cols; j++) {
          const x = j * gridSize + offsetX;
          context.beginPath();
          context.moveTo(x, 0);
          context.lineTo(x, canvas.height);
          context.stroke();

          if (j < cols) {
            const label = prompt(`Enter Easting for border column ${j + 1}:`, `E ${j}`);
            context.fillText(label, x + 5, 15);
          }
        }
      }

      function getColor(x, y) {
        const rowIndex = Math.floor((y - offsetY) / gridSize);
        const colIndex = Math.floor((x - offsetX) / gridSize);
        return grid[rowIndex] ? grid[rowIndex][colIndex] : undefined;
      }

      function setColor(x, y, color) {
        const rowIndex = Math.floor((y - offsetY) / gridSize);
        const colIndex = Math.floor((x - offsetX) / gridSize);

        if (!grid[rowIndex]) {
          grid[rowIndex] = [];
        }

        // Save the current grid state to history before updating
        gridHistory.push([...grid.map(row => [...row])]);

        grid[rowIndex][colIndex] = { color };
        drawOverlay();
      }

      function handleClick(event) {
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        if (isMapLocked) {
          setColor(x, y, selectedColor);
        }
      }

      function handleUndo() {
        if (gridHistory.length > 0) {
          // Pop the last state from history
          grid.splice(0, grid.length, ...gridHistory.pop());
          drawOverlay();
        }
      }

      function toggleMapLock() {
        isMapLocked = !isMapLocked;
        lockUnlockButton.textContent = isMapLocked ? "Unlock Map" : "Lock Map";
      }

      function handleHover(event) {
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        const rowIndex = Math.floor((y - offsetY) / gridSize);
        const colIndex = Math.floor((x - offsetX) / gridSize);

        const northing = prompt("Enter Northing:", `N ${rowIndex + 1}`);
        const easting = prompt("Enter Easting:", `E ${colIndex + 1}`);

        hoverInfo.textContent = `Northing: ${northing}, Easting: ${easting}`;
        hoverInfo.style.left = `${x + 10}px`;
        hoverInfo.style.top = `${y}px`;
      }

      canvas.addEventListener("click", handleClick);
      undoButton.addEventListener("click", handleUndo);
      lockUnlockButton.addEventListener("click", toggleMapLock);
      canvas.addEventListener("mousemove", handleHover);
    });
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    canvas {
      border: 1px solid #000;
      cursor: pointer;
      max-width: 100%; /* Ensure the canvas doesn't exceed the width of the viewport */
      height: auto; /* Maintain the aspect ratio of the canvas */
      transition: transform 0.3s ease-in-out; /* Add a smooth transition for the animation */
    }
  </style>
  <title>Land Capture Game</title>
</head>
<body>
  <label for="scaleSlider">Adjust Grid Scale:</label>
  <input type="range" id="scaleSlider" min="50" max="200" step="50" value="100" />
  <br>
  <label for="colorSelector">Select Team Color:</label>
  <select id="colorSelector">
    <option value="red">Red</option>
    <option value="blue">Blue</option>
    <option value="green">Green</option>
    <option value="yellow">Yellow</option>
    <option value="transparent">Transparent</option>
  </select>
  <br>
  <input type="file" id="imageInput" accept="image/jpeg, image/png" />
  <canvas id="gridCanvas"></canvas>
  <button id="undoButton">Undo</button>
  <script>
    document.addEventListener("DOMContentLoaded", function() {
      const canvas = document.getElementById("gridCanvas");
      const context = canvas.getContext("2d");
      const imageInput = document.getElementById("imageInput");
      const scaleSlider = document.getElementById("scaleSlider");
      const colorSelector = document.getElementById("colorSelector");
      const undoButton = document.getElementById("undoButton");

      let image = new Image();
      let isImageLoaded = false;
      let gridSize = parseInt(scaleSlider.value);
      let selectedColor = colorSelector.value;
      let isDragging = false;
      let dragStartX, dragStartY;

      const grid = [];
      const gridHistory = [];

      imageInput.addEventListener("change", function(event) {
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = function(e) {
            image.src = e.target.result;
          };
          reader.readAsDataURL(file);
        }
      });

      scaleSlider.addEventListener("input", function() {
        gridSize = parseInt(scaleSlider.value);
        drawOverlay();
      });

      colorSelector.addEventListener("change", function() {
        selectedColor = colorSelector.value;
      });

      image.onload = function() {
        isImageLoaded = true;
        canvas.width = image.width;
        canvas.height = image.height;
        drawOverlay();
      };

      function drawOverlay() {
        if (!isImageLoaded) return;

        context.clearRect(0, 0, canvas.width, canvas.height);
        context.drawImage(image, 0, 0, canvas.width, canvas.height);

        context.globalAlpha = 0.5;

        const rows = Math.ceil(canvas.height / gridSize);
        const cols = Math.ceil(canvas.width / gridSize);

        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < cols; j++) {
            const color = grid[i] && grid[i][j] ? grid[i][j] : "transparent";
            context.fillStyle = color;
            context.fillRect(j * gridSize, i * gridSize, gridSize, gridSize);
            context.strokeRect(j * gridSize, i * gridSize, gridSize, gridSize);
          }
        }
        context.globalAlpha = 1;
      }

      function getColor(x, y) {
        const rowIndex = Math.floor(y / gridSize);
        const colIndex = Math.floor(x / gridSize);
        return grid[rowIndex] ? grid[rowIndex][colIndex] : undefined;
      }

      function setColor(x, y, color) {
        const rowIndex = Math.floor(y / gridSize);
        const colIndex = Math.floor(x / gridSize);

        if (!grid[rowIndex]) {
          grid[rowIndex] = [];
        }

        grid[rowIndex][colIndex] = color;
        drawOverlay();
      }

      function handleClick(event) {
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        // Save the current grid state to history before updating
        gridHistory.push([...grid.map(row => [...row])]);

        setColor(x, y, selectedColor);
      }

      function handleMouseDown(event) {
        isDragging = true;
        const rect = canvas.getBoundingClientRect();
        dragStartX = event.clientX - rect.left;
        dragStartY = event.clientY - rect.top;
      }

      function handleMouseMove(event) {
        if (!isDragging) return;

        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        const deltaX = x - dragStartX;
        const deltaY = y - dragStartY;

        dragStartX = x;
        dragStartY = y;

        for (let i = 0; i < grid.length; i++) {
          for (let j = 0; j < grid[i].length; j++) {
            grid[i][j] = "transparent";
          }
        }

        drawOverlay();
        context.translate(deltaX, deltaY);
        drawOverlay();
      }

      function handleMouseUp() {
        isDragging = false;
      }

      function handleUndo() {
        if (gridHistory.length > 0) {
          // Pop the last state from history
          grid.splice(0, grid.length, ...gridHistory.pop());
          drawOverlay();
          animateUndo();
        }
      }

      function animateUndo() {
        // Apply a simple animation to indicate the undo
        canvas.style.transform = "scale(1.1)";
        setTimeout(() => {
          canvas.style.transform = "scale(1)";
        }, 300);
      }

      canvas.addEventListener("click", handleClick);
      canvas.addEventListener("mousedown", handleMouseDown);
      canvas.addEventListener("mousemove", handleMouseMove);
      canvas.addEventListener("mouseup", handleMouseUp);
      undoButton.addEventListener("click", handleUndo);
    });
  </script>
</body>
</html>
